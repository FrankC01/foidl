;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; argparse
; Command line parsing
;
; Copyright (c) Frank V. Castellucci
; All Rights Reserved
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

module minilex

; Using RTL regex_match to construct a mini-lexer

var patterns [
    ; Reserved words
    {
        :type   :comment
        :regex  regex: ";.*"
    }
    ;   Keywords and reserved symbols
    {
        :type   :module
        :regex  regex: "module"
    }
    {
        :type   :variable
        :regex  regex: "var"
    }
    {
        :type   :function
        :regex  regex: "func"
    }
    {
        :type   :private
        :regex  regex: ":private"
    }
    {
        :type   :let
        :regex  regex:"let"
    }
    {
        :type   :match
        :regex  regex: "match"
    }
    {
        :type   :match_guard
        :regex  regex: "\|"
    }
    {
        :type   :match_exprref
        :regex  regex: "%0"
    }
    {
        :type   :default
        :regex  regex: ":default"
    }
    {
        :type   :group
        :regex  regex: "@\("
    }
    {
        :type   :lambda
        :regex  regex: "\^"
    }
    {
        :type   :if_expr
        :regex  regex: "\?:"
    }
    {
        :type   :lparen
        :regex  regex: "\("     ;   Used for partials
    }
    {
        :type   :rparen
        :regex  regex: "\)"
    }
    {
        :type   :math_ref
        :regex  regex: "[+/*-]\\b?"
    }
    {
        :type   :math_call
        :regex  regex: "[+/*-]:\\b?"
    }
    ;   Collection wrapper symbols
    {
        :type   :lbracket
        :regex  regex: "\["     ;   Used for list
    }
    {
        :type   :rbracket
        :regex  regex: "\]"
    }
    {
        :type   :langle
        :regex  regex: "<"      ;   Used for vector
    }
    {
        :type   :rangle
        :regex  regex: ">"
    }
    {
        :type   :lbrace         ;   Used for maps
        :regex  regex: "\{"
    }
    {
        :type   :rbrace
        :regex  regex: "\}"
    }
    {
        :type   :lset
        :regex  regex: "#\{"    ;   Used for sets
    }
    {
        :type   :boolpred
        :regex  regex: "(=|>=|<=|>|<|not=){1,1}:?\\b";

    }
    {
        :type   :funccall
        :regex  regex: "[a-zA-Z]([a-zA-Z0-9]*)?:"
    }
    {
        :type   :funccall_pred
        :regex  regex: "[a-zA-Z]([a-zA-Z0-9]*)?\\?:"
    }
    {
        :type   :funccall_bang
        :regex  regex: "[a-zA-Z]([a-zA-Z0-9]*)?!:"
    }
    {
        :type   :keyword
        :regex  regex: ":[a-zA-Z]([a-zA-Z0-9]*)?"
    }
    ;   Literals
    ;   String is in RTL for now
    {
        :type   :integer
        :regex  regex: "[-+]?[[:digit:]]+?"
    }
    ;   String is in RTL for now
    {
        :type   :char
        :regex  regex:  "'[0-9]{1,1}'"
    }
    {
        :type   :bit
        :regex  regex: "0[bB][0-1]+"

    }
    {
        :type   :hex
        :regex  regex: "0[xX][0-9a-fA-F]+"
    }
    {
        :type   :symbol
        :regex  regex: "[a-zA-Z]([a-zA-Z0-9]*)?"
    }
    {
        :type   :symbol_pred
        :regex  regex: "[a-zA-Z]([a-zA-Z0-9]*)?\\?"
    }
    {
        :type   :symbol_bang
        :regex  regex: "[a-zA-Z]([a-zA-Z0-9]*)?!"
    }
]

var ignores [
    {
        :type   :ignore
        :regex  regex: "[,\t ]+"
    }
]

func main [argv]
    print!: nlchr
    ?: =: count: argv 2
        let [src_string quaf!: get: argv 1]
            @(
                print!: "Contents of " printnl!: get: argv 1
                printnl!: src_string
                printnl!: "Tokenized content intermed"
                tokenize: src_string patterns ignores true
            )
        printnl!: "usage 'minilex foidl_source"

