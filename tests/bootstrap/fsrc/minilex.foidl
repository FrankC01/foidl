;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; argparse
; Command line parsing
;
; Copyright (c) Frank V. Castellucci
; All Rights Reserved
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

module minilex

; Using RTL regex_match to construct a mini-lexer

var patterns [
    {
        :type   :module
        :regex  regex: "module"
    }
    {
        :type   :include
        :regex  regex: "include"
    }
    {
        :type   :variable
        :regex  regex: "var"
    }
    {
        :type   :function
        :regex  regex: "func "
    }
    {
        :type   :private
        :regex  regex: ":private"
    }
    {
        :type   :let
        :regex  regex:"let"
    }
    {
        :type   :match
        :regex  regex: "match"
    }
    {
        :type   :match_guard
        :regex  regex: "\|"
    }
    {
        :type   :match_exprref
        :regex  regex: "%0"
    }
    {
        :type   :default
        :regex  regex: ":default"
    }
    {
        :type   :group
        :regex  regex: "@\("
    }
    {
        :type   :lambda
        :regex  regex: "\^"
    }
    {
        :type   :lparen
        :regex  regex: "\("     ;   Used for partials
    }
    {
        :type   :rparen
        :regex  regex: "\)"
    }
    {
        :type   :math_call
        :regex  regex: "(\+|-|/|\*):{1,1}?"
    }
    {
        :type   :boolpred_call
        :regex  regex: "(=|>=|<=|>|<|not=):"
    }
    {
        :type   :lbracket
        :regex  regex: "\["     ;   Used for list
    }
    {
        :type   :rbracket
        :regex  regex: "\]"
    }
    {
        :type   :langle
        :regex  regex: "<"      ;   Used for vector
    }
    {
        :type   :rangle
        :regex  regex: ">"
    }
    {
        :type   :lbrace         ;   Used for maps
        :regex  regex: "\{"
    }
    {
        :type   :rbrace
        :regex  regex: "\}"
    }
    {
        :type   :lset
        :regex  regex: "#\{"    ;   Used for sets
    }
    {
        :type   :funccall
        :regex  regex: "[a-zA-Z]([a-zA-Z0-9_]*)?:"
    }
    {
        :type   :funccall_pred
        :regex  regex: "[a-zA-Z]([a-zA-Z0-9_]*)?\?:"
    }
    {
        :type   :funccall_bang
        :regex  regex: "[a-zA-Z]([a-zA-Z0-9_]*)?!:"
    }
    {
        :type   :keyword
        :regex  regex: ":[a-zA-Z]([a-zA-Z0-9_]*)?"
    }
    {
        :type   :real_number
        :regex  regex: "-?(?:0|[1-9]\d*)\.\d*(?:[eE][+\-]?\d+)?"
    }
    {
        :type   :real_number
        :regex  regex: "-?[0-9]+?\.[0-9]+?"
    }
    {
        :type   :bit
        :regex  regex: "0[bB][0-1]+"

    }
    {
        :type   :hex
        :regex  regex: "0[xX][0-9a-fA-F]+"
    }
    {
        :type   :integer
        :regex  regex: "-?[0-9]+"
    }
    {
        :type   :math_ref
        :regex  regex: "(\+|-|\/|\*)"
    }
    {
        :type   :char
        :regex  regex:  "\'[0-9a-zA-Z]*?\'"
    }
    {
        :type   :symbol_pred
        :regex  regex: "[a-zA-Z]([a-zA-Z0-9_]*)?\?"
    }
    {
        :type   :symbol_bang
        :regex  regex: "[a-zA-Z]([a-zA-Z0-9_]*)?!"
    }
    {
        :type   :symbol
        :regex  regex: "[a-zA-Z]([a-zA-Z0-9_]*)?"
    }
    {
        :type   :if_expr
        :regex  regex: "\?:"
    }
    {
        :type   :comment
        :regex  regex: ";.*"
    }
]

;   List  of ignores
var ignores [
    {
        :type   :ignore
        :regex  regex: "[,\t ]+"
    }
]

func dump_toks [toks]
    printnl!: "Tokenized content top down"
    let rev_toks []
        fold: ^[a m]
            @(
                printnl!: m
                extend: a m
            ) [] toks
    printnl!: "`nTokenized content reversed"
    fold: ^[a m] @(printnl!: m a) nil rev_toks

func token_results [toks]
    match count: toks
    | 0     printnl!: "No tokens found"
    | 1     printnl!: get: toks 0
    | :default dump_toks: toks

func main [argv]
    print!: nlchr
    ?: =: count: argv 2
        let [src_string quaf!: get: argv 1
             toks tokenize: src_string patterns ignores]
             token_results: toks
        printnl!: "usage 'bin/minilex fsrc/minilex.foidl'`n"

