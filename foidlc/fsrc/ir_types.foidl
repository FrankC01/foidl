;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ir_types
; LLVM Generation
;
; Copyright (c) Frank V. Castellucci
; All Rights Reserved
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

module ir_types
include langcorem

include ast_type
include errors

; Integer types
var int_64  inttype: 64
var int_32  inttype: 32
var int_8   inttype: 8

; Well knowns
var any         named_struct_type: "Any"
var any_ptr     ptr_type: any
var any_ptr_ptr ptr_type: any_ptr

var void_ptr        ptr_type: int_8         ; i8*
var void_ptr_ptr    ptr_type: void_ptr      ; i8**

var null const_type: "null"
var void const_type: "void"

var return_void return_type: void

var :private label "label "

; Templatized

; For var and literal local declarations
var :private global_null_decl "@`d{}`d = {} %`dAny`d* null, align 8`n"

; For external function declarations
var :private anyptr_name "%`dAny`d* %`d{}`d"
var :private anyptr_tailname ", %`dAny`d* %`d{}`d"
var :private extr_func "declare %`dAny`d* @`d{}`d({})`n"

; For external var declarations
var :private extr_var "@`d{}`d = {} %`dAny`d*, align 8`n"

; Function: ir_stringify
; Description: expand string if ? and *
var :private bang "{}_bang"
var :private pred "{}_qmark"

func :private ir_stringify [s]
    match last: s
    | '?'   format!: pred [dropLast: s]
    | '!'   format!: bang [dropLast: s]
    | :default s

; Simple tostr

func :private simple_name_tostring [irtype]
    format!: get: irtype :declaration [get: irtype :name]

func :private type_tostring [irtype]
    let rts_fn  [] get: irtype :tostring
    (rts_fn irtype)

; Simple writer

func :private simple_name_writer [ochan irtype]
    let tstr_fn [] get: irtype :tostring
    write!: ochan (tstr_fn irtype)

; Simple integer type

func inttype [val]
    {
        :type           :int
        :name           val
        :declaration    "i{}"
        :writer         simple_name_writer
        :tostring       simple_name_tostring
    }

; Pointer types

func :private pointer_tostring [ptype]
    type_tostring: ptype

func :private pointer_writer [ochan ptype]
    write!:
        ochan
        format!:
            get: ptype :declaration
            [pointer_tostring: get: ptype :valtype]

func ptr_type [valtype]
    {
        :type           :ptr
        :valtype        valtype
        :declaration    "{}*"
        :writer         pointer_writer
        :tostring       pointer_tostring
    }

; Const types

func const_type [val]
    {
        :type           :constant
        :name           val
        :declaration    "{}"
        :writer         simple_name_writer
        :tostring       simple_name_tostring
    }

; Comment

func comment_type [val]
    {
        :type           :constant
        :name           val
        :declaration    "`n; {} `n"
        :writer         simple_name_writer
        :tostring       simple_name_tostring
    }

; Literal declaration

func literal_type  [litref]
    {
        :type           :literal
        :name           get: litref NAME
        :ltype          get: litref LITTYPE
        :lval           get: get: litref TOKEN :token_str
        :declaration    "@`d{}`d = private global %`dAny`d* null, align 8`n"
        :writer         simple_name_writer
        :tostring       simple_name_tostring
    }

; Return type

func :private return_writer [ochan rettype]
    let rtype   [] get: rettype :returns
    write!:
        ochan
        format!:
            get: rettype :declaration
            [type_tostring: rtype]

func return_type [retref]
    {
        :type           :return_type
        :returns        retref
        :declaration    "`t return {}`n}`n"
        :writer         return_writer
    }

; Array types

func :private array_type_tostring [arrtype]
    format!:
        get: arrtype :declaration
        [   get: arrtype :count
            type_tostring: get: arrtype :eltype
        ]

func :private array_type_writer [ochan arrtype]
    let astr_fn [] get: arrtype :tostring
    write!: ochan (astr_fn arrtype)

func array_type [eltype cnt]
    {
        :type           :array_type
        :eltype         eltype
        :count          cnt
        :declaration    "[{} x {}]"
        :writer         array_type_writer
        :tostring       array_type_tostring
    }

; Basic block - named container of instructions

func :private bblock_writer [ochan bblock]
    ochan

func basic_block_type [val]
    map_extend!:
        {
            :type           :basic_block
            :name           val
            :instructions   list_inst!:
            :inst_pos       zero
            :declaration    "{}:`n"
        }
        :writer bblock_writer

; Generic named type

func named_struct_type [val]
    {
        :type           :structure
        :name           val
        :declaration    "%`d{}`d"
        :writer         simple_name_writer
        :tostring       simple_name_tostring
    }


; External declaration - Applies to extern vars and funcs

func external_variable_type [val]
    {
        :type           :external_var
        :name           ir_stringify: get: val NAME
        :declaration    "@`d{}`d = external global %`dAny`d* null, align 8`n"
        :writer         simple_name_writer
        :tostring       simple_name_tostring
    }

func :private anyptr_for [aptrstr r]
    format!: aptrstr [r]

func :private extern_func_writer [ochan efunc]
    write!:
        ochan
        format!:
        get: efunc :declaration
        [
            get: efunc :name
            ?: =: get: efunc :argcnt zero
                " "
                fold:
                    ^[istr ndx]
                        ?: =: ndx zero
                            extend: istr anyptr_for: anyptr_name ndx
                            extend: istr anyptr_for: anyptr_tailname ndx
                    "" series: zero get: efunc :argcnt one]

    ochan

func external_function_type [funcref]
    map_extend!:
        {
            :type           :external_func
            :name           ir_stringify: get: funcref NAME
            :argcnt         get: funcref ARGCNT
            :declaration    "declare %`dAny`d* @`d{}`d({})`n"
        }
        :writer  extern_func_writer

; Local declarations - Applies to private literals and private/general vars

; Function: global_function
; Description: Instantiates a function
;   1. Create "entry:" basic block
;   2. If return is nil, set constant void

func :private function_writer [ochan gft]

func  global_function_type [val args exprs rettype]
    let gf []
            {
                :type           :function
                :name           ir_stringify: val
                :bblocks_map    map_inst!:
                :basic_blocks   list_inst!:
                :arguments      list_inst!:
                :expressions    exprs
                :returns        rettype
                :declaration    "define %{} @`d{}`d({}) {`n"
                :writer         function_writer
            }

    list_extend!: get: gf :basic_blocks basic_block_type: "entry"
    map_inst!: get: gf :bblocks_map "entry" zero
    gf

func :private variable_writer [ochan gvt]
    write!:
        ochan
        format!:
            get: gvt :declaration
            [
                get: gvt :name
                ?: get: gvt :private
                    "private global"
                    "default global"
                ]

func global_variable_type [variable]
    map_extend!:
        {
            :type           :variable
            :name           ir_stringify: get: variable NAME
            :expressions    get: variable EXPRS
            :private        get: variable IS_PRIVATE
            :declaration    "@`d{}`d = {} %`dAny`d* null, align 8`n"
        }
        :writer variable_writer

func branch []
func unconditional_branch []
func label_type [astel suffix]
func function_type [function]
func lambda_type [lambda]
