;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; enit
; LLVM Generation
;
; Copyright (c) Frank V. Castellucci
; All Rights Reserved
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

module emit

include langcorem
include ast_type
include ir_types


; Emit supports most LLVM instructions
; Manages global local function references
; Manages reference types (litref, etc.)

var :private context {
    :global_vars    map_inst!:
    :global_funcs   map_inst!:
    :module_bb      list_inst!:
}

var selfhost_llvm ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; {}
; Generated by foidlc - Self-hosted foidl compiler
; Copyright (c) Frank V. Castellucci
; All rights reserved
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

target triple = `dunknown-unknown-unknown`d
target datalayout = `d`d`n
"

var :private module_id "; Module ID = `d{}`d`n"

var :private context_str "%`dAny`d = type {i64, i64, i64, i32, i8*}
%VPAT = type { i32, void ()*, i8* }

@llvm.global_ctors = appending global [1 x %VPAT]
    [%VPAT { i32 65535, void ()* @foidl_module_inits, i8* null }]`n
; RTL helpers`n
declare %`dAny`d* @`dfoidl_rtl_init`d()

define internal void @foidl_module_inits()
    section `d__TEXT,__StaticInit,regular,pure_instructions`d {
    %res = call %`dAny`d* @`dfoidl_rtl_init`d()"

var :private context_tail "
    call void @`d{}_linits`d()
    call void @`d{}_vinits`d()
    ret void
}

declare %`dAny`d* @`dfoidl_convert_mainargs`d(i32 %`d.1`d, i8** %`d.2`d, i8** %`d.3`d)
declare %`dAny`d* @`dfoidl_reg_character`d(i64 %`d.1`d)
declare %`dAny`d* @`dfoidl_reg_integer`d(i64 %`d.1`d)
declare %`dAny`d* @`dfoidl_reg_keyword`d(i8* %`d.1`d)
declare %`dAny`d* @`dfoidl_reg_string`d(i8* %`d.1`d)
declare %`dAny`d* @`dfoidl_tofuncref`d(i8* %`d.1`d, %`dAny`d* %`d.2`d)
declare %`dAny`d* @`dfoidl_imbue`d(%`dAny`d* %`d.1`d, %`dAny`d* %`d.2`d)
declare %`dAny`d* @`dfoidl_fref_instance`d(%`dAny`d* %`d.1`d)`n"


; Function: initialize
; Description: sets up additional context information

func :private initialize [state]
    map_extend!:
        context
        :module_name get: state :module_name
    state

; Function: spit_header
; Description: Emits the static header

func :private spit_header [state]
    let oc      [] get: state :outchannel
    let mname   [] get: context :module_name
    write!: oc format!: selfhost_llvm [mname]
    write!: oc format!: module_id [mname]
    write!: oc context_str
    write!: oc format!: context_tail [mname mname]
    state

; Function: spit
; Description: Writes el to ochan and returns ochan

func :private spit [ochan el]
    let write_fn [] get: el :writer
    (write_fn ochan el)
    ochan

; Function: emit_externals
; Description: Captures an external var or func declaration type

func :private emit_externals [acc el]
    let elref [] value: el
    ?: =: get: elref TYPE :varref
        list_extend!: acc external_variable_type: elref
        list_extend!: acc external_function_type: elref
    acc

; Function: externs
; Description: processes any external declarations

func :private externs [state]
    list_extend!: get: context :module_bb
        comment_type: "External references`n"
    fold:
        emit_externals
        get: context :module_bb
        get: get: state :ast EXTERNS
    state

; Function: emit_literals
; Description: Captures literal declaration instructions

func :private emit_literals [acc el]
    ?: empty?: value: el
        acc
        fold:
            ^[instr lit]
                list_extend!:
                    instr
                    literal_type: value: lit
            acc value: el

; Function: literals
; Description: process any literals
; and create a mname_linits() function

func :private literals [state]
    let mbb [] get: context :module_bb
    list_extend!: mbb comment_type: "Literal references`n"
    let bsc [] count: mbb
    fold:
        emit_literals
        get: context :module_bb
        get: get: state :ast LITERALS
    ;printnl!: bsc
    ;printnl!: count: mbb
    let atype [] array_type: int_8 bsc
    let atptr [] ptr_type: atype
    list_extend!: mbb comment_type: "Literal initializers`n"
    list_extend!:
        mbb
        global_function_type:
            format!: "{}_linits" [get: state :module_name]
            []
            []
            return_void

    ;list_extend!: mbb atype
    ;list_extend!: mbb atptr
    state

func :private variables [state]
    list_extend!: get: context :module_bb
        comment_type: "Local variable references`n"
    fold:
        ^[acc decl]
            ?: =: get: decl TYPE :variable
                list_extend!: acc global_variable_type: decl
                acc
        get: context :module_bb
        get: get: state :ast EXPRS
    state

func :private lambdas [state]
    state

func :private functions [state]
    state

func :private vinits [state]
    state

func :private ctor [state]
    state

func emit [state]
    ctor:
    vinits:
    functions:
    lambdas:
    variables:
    literals:
    externs:
    spit_header:
    initialize: state

    fold: spit get: state :outchannel get: context :module_bb

