;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; emit
; LLVM Generation
;
; Copyright (c) Frank V. Castellucci
; All Rights Reserved
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

module emit

include langcorem
include ast_type
include ir_types

include emit_utils


; Emit supports most LLVM instructions
; Manages global local function references
; Manages reference types (litref, etc.)

var :private context {
    :global_vars    map_inst!:
    :global_funcs   map_inst!:
    :module_bb      list_inst!:
}

var selfhost_llvm ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; {}
; Generated by foidlc - Self-hosted foidl compiler
; Copyright (c) Frank V. Castellucci
; All rights reserved
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

target triple = `dunknown-unknown-unknown`d
target datalayout = `d`d
source_filename = `d{}`d`n
"

var :private module_id "; Module ID = `d{}`d`n"

var :private context_str "%`dAny`d = type {i64, i64, i64, i32, i8*}
%VPAT = type { i32, void ()*, i8* }

@llvm.global_ctors = appending global [1 x %VPAT]
    [%VPAT { i32 65535, void ()* @foidl_module_inits, i8* null }]`n
; RTL helpers`n
declare %`dAny`d* @`dfoidl_rtl_init`d()

define internal void @foidl_module_inits()
    section `d__TEXT,__StaticInit,regular,pure_instructions`d {
    %res = call %`dAny`d* @`dfoidl_rtl_init`d()"

var :private context_tail "
    call void @`d{}_linits`d()
    call void @`d{}_vinits`d()
    ret void
}

declare i64 @`dfoidl_return_code`d(%`dAny`d* %`d.1`d)
declare %`dAny`d* @`dfoidl_convert_mainargs`d(i32 %`d.1`d, i8** %`d.2`d, i8** %`d.3`d)
declare %`dAny`d* @`dfoidl_reg_character`d(i64 %`d.1`d)
declare %`dAny`d* @`dfoidl_reg_integer`d(i64 %`d.1`d)
declare %`dAny`d* @`dfoidl_reg_keyword`d(i8* %`d.1`d)
declare %`dAny`d* @`dfoidl_reg_string`d(i8* %`d.1`d)
declare %`dAny`d* @`dfoidl_tofuncref`d(i8* %`d.1`d, %`dAny`d* %`d.2`d)
declare %`dAny`d* @`dfoidl_imbue`d(%`dAny`d* %`d.1`d, %`dAny`d* %`d.2`d)
declare %`dAny`d* @`dfoidl_fref_instance`d(%`dAny`d* %`d.1`d)`n"

var :private main_string "
define i64 @`dmain`d(i32 %`dargc`d, i8** %`dargv`d, i8** %`denvp`d)
{
entry:
  %`d.5`d = call %`dAny`d* @`dfoidl_convert_mainargs`d(i32 %`dargc`d, i8** %`dargv`d, i8** %`denvp`d)
  %`d.6`d = call %`dAny`d* @`duser_main`d(%`dAny`d* %`d.5`d)
  %`d.7`d = call i64 @`dfoidl_return_code`d(%`dAny`d* %`d.6`d)
  ret i64 %`d.7`d
}`n"

var :private main_noarg_string "
define i64 @`dmain`d(i32 %`dargc`d, i8** %`dargv`d, i8** %`denvp`d)
{
entry:
  %`d.5`d = call %`dAny`d* @`dfoidl_convert_mainargs`d(i32 %`dargc`d, i8** %`dargv`d, i8** %`denvp`d)
  %`d.6`d = call %`dAny`d* @`duser_main`d()
  %`d.7`d = call i64 @`dfoidl_return_code`d(%`dAny`d* %`d.6`d)
  ret i64 %`d.7`d
}`n"

; Function: initialize
; Description: sets up additional context information

func :private initialize [state]
    map_extend!:
        context
        :module_name get: state :module_name
    state

; Function: spit_header
; Description: Emits the static header

func :private spit_header [state]
    let oc      [] get: state :outchannel
    let mname   [] get: context :module_name
    write!: oc format!: selfhost_llvm [mname get: state :source]
    write!: oc format!: module_id [mname]
    write!: oc context_str
    write!: oc format!: context_tail [mname mname]
    state

; Function: spit
; Description: Writes el to ochan and returns ochan

func :private spit [ochan el]
    let write_fn [] get: el :writer
    (write_fn ochan el)
    ochan

; Function: emit_externals
; Description: Captures an external var or func declaration type

func :private emit_externals [acc el]
    let elref [] value: el
    ?: =: get: elref TYPE :varref
        list_extend!: acc external_variable_type: elref
        list_extend!: acc external_function_type: elref
    acc

; Function: externs
; Description: processes any external declarations

func :private externs [state]
    list_extend!: get: context :module_bb
        comment_type: "External references`n"
    fold:
        emit_externals
        get: context :module_bb
        get: get: state :ast EXTERNS
    state

; Function: literals
; Description: Builds the literal private declarations and
; andy run-time initializers

func :private literals [state]
    let mbb [] get: context :module_bb
    list_extend!: mbb comment_type: "Literal references`n"

    ; Get the starting position to optimize literal
    ; initializer scanning
    let bsc [] count: mbb
    let lits [] get: get: state :ast LITERALS
    ; Emit the literal declarations
    fold:
        emit_literal_declarations
        get: context :module_bb
        lits

    ; Emit the "modulename_linits function"
    let lit_fn []
        global_function_type:
            format!: "{}_linits" [get: state :module_name]
            true
            []
            "void"
            return_void

    ; Get functions basic block
    let lit_bb [] get_basic_block: lit_fn

    ; Setup reusable serializer based on actual literal
    ; declaration counts
    let litser [] series: bsc count: mbb one

    ; Insert comment and function definition
    list_extend!: mbb comment_type: "Literal initializers"
    list_extend!: mbb lit_fn

    ; Check for max string/keyword length
    let lit_maxlen [] fold: (literal_max_len mbb) zero litser

    ; Prepare local buffer if there are strings
    let basebufcast []
        ?: =: lit_maxlen zero
            nil
            literal_buffer_setup:
                lit_fn
                lit_bb
                lit_maxlen


    ; Emit the literal registrations
    fold:
        (literal_registration basebufcast lit_fn get: lit_bb :instructions)
        mbb litser
    state

; Function: variables
; Description: Create variable pointer declarations
; Variable expression initialization is deferred to vinits

func :private variables [state]
    list_extend!: get: context :module_bb
        comment_type: "Local variable references`n"
    fold:
        ^[acc decl]
            ?: =: get: decl TYPE :variable
                list_extend!: acc global_variable_type: decl
                acc
        get: context :module_bb
        get: get: state :ast EXPRS
    state

; Function: emit_function
; Description: basic function evaluation for both lambdas and functions

func :private emit_function [acc fn_el]
    let nfunc [] new_function: fn_el
    let nfunc_bb [] get_basic_block: nfunc
    let frame [] list_inst!:

    ; Emit instructions
    expression_emitter:
        nfunc
        frame
        get: nfunc_bb :instructions
        get: fn_el EXPRS

    ; Get last expression result register and reset return
    ?: empty?: frame
        nil     ;   Should be exception in the end
        map_extend!:
            nfunc
            :returns
            return_type: last: frame
    list_extend!: acc nfunc

; Function: lambdas
; Description: Processes lambda definitions

func :private lambdas [state]
    list_extend!: get: context :module_bb
        comment_type: "Local lambda definitions`n"
    fold: emit_function get: context :module_bb get: get: state :ast LAMBDAS
    state

; Function: main_test
; Description: Checks if the function is main

func :private main_test [state decl]
    ?: =: get: decl NAME "main"
        @(
            map_extend!: decl NAME "user_main"
            map_extend!: state :main_hit decl
        )
        state
; Function: functions
; Description: Processes function definitions

func :private functions [state]
    list_extend!: get: context :module_bb
        comment_type: "Local function definitions`n"
    fold:
        ^[acc decl]
            ?: =: get: decl TYPE :function
                @(
                    main_test: state decl
                    emit_function: acc decl
                )
                acc
        get: context :module_bb
        get: get: state :ast EXPRS
    state

; Function: emit_var_expression
; Description: Emits a var expression with store back to
; variable declaration in "modulename_vinits"

var :private one_time_var list_inst!:

func :private emit_var_expression [v_fn v_bb decl]
    ?: =: get: decl TYPE :variable
            @(
                expression_emitter: v_fn one_time_var v_bb get: decl EXPRS
                list_extend!:
                    v_bb
                        store:
                        last: one_time_var
                        reference_constant_type:
                            any_ptr_ptr
                            global_reference: get: decl NAME
            )
        v_bb

; Function: vinits
; Description: Builds the variable run-time initializers

func :private vinits [state]
    let mbb [] get: context :module_bb
    ; Emit the "modulename_vinits function"
    let vit_fn []
        global_function_type:
            format!: "{}_vinits" [get: state :module_name]
            true
            []
            "void"
            return_void

    ; Get functions basic block
    let vit_bb [] get_basic_block: vit_fn
    list_extend!: mbb comment_type: "Variable initializers"
    list_extend!: mbb vit_fn
    fold:
        (emit_var_expression vit_fn)
        get: vit_bb :instructions
        get: get: state :ast EXPRS
    state

; Function: user_defined_main
; Description: Processes a user defined 'main' function
; for the module

func :private user_defined_main [state]
    ?: let decl [] getd: state :main_hit false
        write!:
            get: state :outchannel
            match get: get: decl ARGLIST ARGCNT
                | 0         main_noarg_string
                | :default  main_string
        nil
    state

; Function: emit
; Description: Walks the ast, emitting LLVM in it's
; walking wakedness

func emit [state]
    user_defined_main:
    vinits:
    functions:
    lambdas:
    variables:
    literals:
    externs:
    spit_header:
    initialize: state

    fold: spit get: state :outchannel get: context :module_bb

