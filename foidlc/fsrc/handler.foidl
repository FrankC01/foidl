;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; handler
; Compilation handler builder
;
; Copyright (c) Frank V. Castellucci
; All Rights Reserved
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

module handler

include langcorem

include lexer
include token_utils

var selfhost_comment ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generated by foidlc - Self-hosted foidl compiler
; Copyright (c) Frank V. Castellucci
; All rights reserved
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
"

; Write out the top comment block
func :private write_comment_block [ochan]
    write!: ochan selfhost_comment
    write!: ochan nlchr

; Write out top comment block followed by module statement
func :private write_comment_block_and_module [ochan modname]
    write_comment_block: ochan
    write!: ochan "module " write!: ochan modname
    write!: ochan nlchr

; Function: module_name_validation
; Description: Takes top entry from token list and validates
; it is a module statement and returns it. If not, report error
; Syntax: module_name_validation: toks
;   toks - Token list

func :private module_name_validation [toks]
    let [first_tok first: toks
         mname_tok second: toks]
        ?: and: =: get: first_tok :token_type :module
                =: get: mname_tok :token_type :symbol
            mname_tok
            @(
                write!: cerr "Exception: A valid module statement must be first, found "
                write!: cerr get: first_tok :token_type
                write!: cerr " "
                write!: cerr get: mname_tok :token_str
                write!: cerr nlchr
                fail:
            )

; Function: token_printer
; Description: Prints token list
; Syntax: token_printer: state
;   state - Command line flags and state settings

func :private token_print [state]
    fold:
        ^[acc el]
            @(
                write!: cout el
                write!: cout nlchr
            )
        nil get: state :tokens
    state

; Function: lex_source
; Description: Lexical scan of source file and initial validation
; Syntax: lex_source: cmap source
;   keep_empty - Prevents fail on empty token file
;   state - Command line flags and state settings

func :private lex_source [keep_empty state]
    print!: "Lexing source -> "
    printnl!: get: state :source
    let [tokens lex: get: state :source #{:comment} keep_empty
         mname_tok module_name_validation: tokens]
            map_extend!:
                map_extend!: state :module_name get: mname_tok :token_str
                :tokens tokens

; Function: setup_output
; Description: Opens a channel for indicated output or uses
; cout and sets in cmap, which is returned
; Syntax: setup_output: state
;   state - Command line flags and state settings

func :private setup_output [state]
    let output [] get: get: state :cmap :output
    ?: output
        map_extend!: state :outchannel
                open!: {
                    :channel output
                    :open :w
                    :buffer :block
                    :write_handler :char }
        map_extend!: state :outchannel cout

func :private setup_symboltable [state]
    printnl!: "Setting up sym table"
    state

; Include processing

var :private include_rthdrs <"foidlrt" "langcore">
var :private include_tail ".defs"
var :private include_existserr " Unable to resolve include file: "

var :private include_cache map_inst!:
var :private include_paths list_inst!:

; Function: capture_includes
; Description: Local capture of include paths when
; command is to compile

func :private capture_includes [state]
    fold:
        ^[acc clineinc]  list_extend!: acc clineinc
        include_paths get: get: state :cmap :includes
    state

; Function: resolve_include_location
; Description: For each file, search the include paths and test
; for existence

func :private resolve_include_location [incfile]
    let fullfile [] extend: incfile include_tail
    fold: ^[res ipath]
            @(
                let fqn [] extend: ipath fullfile
                ?: fileExists?: fqn
                    reduced: fqn
                    res
            )
        nil include_paths

; Function: preload_langhdrs
; Description: Load the foidlrt and langcore headers to
; feed the symbol table prior to parsing tokens
; Syntax: preload_langhdrs: state
;   state - Command line flags and state settings

func :private preload_langhdrs [state]
    ; For each include file, determine path based on
    ; include searching
    let res []
        fold:
            ^[acc incfile]
                let [hit resolve_include_location: incfile]
                    ?: hit
                        list_extend!: acc hit
                        acc
            list_inst!: include_rthdrs
    ?: not=: count: res two
        failWith: "Something is awry"
        nil
    let stuff []
        fold:
            ^[a b]
                list_extend!:
                    a
                    build_handler_and_run: {
                        :source     b
                        :command    :procinc
                    }
            list_inst!: res
    state

func :private process_includes [state]
    printnl!: "Process includes"
    state

func :private ast_print2 [state] ; Temporary name
    print!: "Print AST"
    state

func :private consume_include [state]
    print!: "Consume include. Token count -> "
    printnl!: count: get: state :tokens
    state

func :private consume_includes [state]
    printnl!: "Consume includes"
    state

func :private reverse_tokens [state]
    printnl!: "Reversing tokens"
    state

func :private parse_tokens   [state]
    printnl!: "Create AST"
    state

func :private ast_print   [state]
    printnl!: "Print AST"
    state

func :private parse_tree   [state]
    printnl!: "Creating PAST"
    state

func :private produce_ir   [state]
    printnl!: "Creating 3AC"
    state

func :private ir_print   [state]
    printnl!: "Print 3AC"
    state

func :private emit_llvm   [state]
    printnl!: "Emit LLVM"
    state

; Function: func_genhdr_writer
; Description: Writes out function signature in genheader processing
; Syntax: func_genhdr_writer: ochan stok arglist acnt
;   ochan   - The output channel
;   ntok    - The symbol found for the function
;   arglist - List of argument symbols (if any)
;   acnt    - Count of args in arglist

func :private func_genhdr [ochan ntok arglist acnt]
    write!: ochan "func "
    write!: ochan get: ntok :token_str
    write!: ochan " ["
    ?: >: acnt zero
        fold:
            ^[acc indx]
                @(
                    ?: >: indx 0
                        write!: ochan " "
                        nil
                    write!: ochan get: arglist indx
                    acc
                )
            nil series: 0 acnt 1
        nil
    write!: ochan "]"
    write!: ochan nlchr

; Function: var_genhdr
; Description: Writes out variable signature in genheader processing
; Syntax: func_genhdr_writer: ochan ntok
;   ochan   - The output channel
;   ntok    - The symbol found for the variable

func :private var_genhdr [ochan ntok]
    write!: ochan "var "
    write!: ochan get: ntok :token_str
    write!: ochan " any"
    write!: ochan nlchr

; Function: genheader
; Description: Generates module, public vars and public funcs
; to designated output
; Rules:
;   Comment block
;   'module name'       : name is already part of state
;   'var name Any'      : name is token right after var if not :private
;   'func name [args]'  : name is token right after func if not :private
; Syntax: genheader: state
;   state - Command line flags and state settings

func :private genheader [state]
    let ochan [] get: state :outchannel
    let tks [] get: state :tokens
    let maxcount [] count: tks
    write_comment_block_and_module: ochan get: state :module_name
    ; Walk tokens and spit vars and funcs
    fold:
        (tpdwn_vf_processor
            (var_genhdr ochan)
            (func_genhdr ochan) tks maxcount)
        0 infinite
    write!: ochan nlchr
    state

; Function: close_output
; Description: Closes, if not stdout, the output channel
; Syntax: close_output: state
;   state - Command line flags and state settings

func :private close_output [state]
    let output [] get: state :outchannel
    ?: =: output cout
        state
        close!: output
    state

; Function: skip_step
; Description: Passthrough step returns state and
; is used when the debugging (-pt, -pa, -pi) are not specified

func :private skip_step [state]
    state

; Place holder for dev
func :private faux_step [s state]
    print!: "Place holder step for " printnl!: s
    state

; Function: build_handler
; Description: Constructs a compilation pipeline based on the
; command line information
; Syntax: build_handler: cmap
;   cmap - Command line flags and settings
; pipeline examples
; If -c command
;   lex_source          - inserts tokens into state
;   [token_print]       - optionally print tokens
;   setup_output        - opens an output channel
;   setup_symboltable   - sets a symbol table up
;   [preload_langincs]  - Preprocess foidlrt and langcore if !-r
;   process_includes    - seperate include(s) from main tokens
;   consume_includes    - consume includes, calls consume_include for each
;   reverse_tokens      - support bottom up parsing
;   parse_tokens        - parse the tokens to abstract syntax tree (AST)
;   [ast_print]         - optionally prints AST
;   parse_tree          - walks AST, generate parse abstract syntax tree (PAST)
;   produce_ir          - walks PAST, creates three address code list (3AC)
;   [ir_print]          - optionally print 3AC
;   emit_llvm           - Emits LLVM-IR from 3AC
;   close_output        - Closes output channel
;
; If -g command
;   lex_source          - inserts tokens into state
;   [token_print]       - optionally print tokens
;   setup_output        - opens an output channel
;   genheader           - Emits foidl defs
;   close_output        - Closes output channel
;
; If -i command
;   lex_source          - inserts tokens into state
;   consume_include     - Generate symbol table references


func build_handler_and_run [cmap]

    let state []
        {
            :cmap           cmap
            :source         get: cmap :source
        }

    ; Capture the include paths if coming in with :compile

    match pipeline get: cmap :command
        | :compile  [
                    capture_includes
                    (lex_source false)
                    ?: get: cmap :printtoks
                        token_print
                        skip_step
                    setup_output
                    (faux_step "setup_symboltable")
                    ?: get: cmap :compiling_runtime
                        skip_step
                        preload_langhdrs
                    (faux_step "process_includes")
                    (faux_step "consume_includes")
                    (faux_step "reverse_tokens")
                    (faux_step "parse_tokens")
                    ?: get: cmap :printast
                        (faux_step "ast_print")
                        skip_step
                    (faux_step "parse_tree")
                    (faux_step "produce_ir")
                    ?: get: cmap :printir
                        (faux_step "ir_print")
                        skip_step
                    (faux_step "emit_llvm")
                    close_output
                    ]
        | :genhdr   [
                    (lex_source false)
                    ?: get: cmap :printtoks
                        token_print
                        skip_step
                    setup_output
                    genheader
                    close_output
                    ]
        | :procinc  [
                    (lex_source true)
                    consume_include
                    ]
        | :default  @(
                        write!: cerr "Invalid switch found in build_handler "
                        write!: cerr %0
                        write!: cerr nlchr
                        fail:
                    )
    fold: ^[acc el] (el acc) state pipeline

