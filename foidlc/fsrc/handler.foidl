;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; handler
; Compilation handler builder
;
; Copyright (c) Frank V. Castellucci
; All Rights Reserved
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

module handler

include langcorem

include lexer
include foidlc_utils
include token_utils

var selfhost_comment ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generated by foidlc - Self-hosted foidl compiler
; Copyright (c) Frank V. Castellucci
; All rights reserved
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
"

; Write out the top comment block
func :private write_comment_block [ochan]
    write!: ochan selfhost_comment
    write!: ochan nlchr

; Write out top comment block followed by module statement
func :private write_comment_block_and_module [ochan modname]
    write_comment_block: ochan
    write!: ochan "module " write!: ochan modname
    write!: ochan nlchr


; Function: token_printer
; Description: Prints token list
; Syntax: token_printer: state
;   state - Command line flags and state settings

func :private token_print [state]
    fold:
        ^[acc el]
            @(
                write!: cout el
                write!: cout nlchr
            )
        nil get: state :tokens
    state

; Function: lex_source
; Description: Lexical scan of source file and initial validation
; Syntax: lex_source: cmap source
;   keep_empty - Prevents fail on empty token file
;   state - Command line flags and state settings

func :private lex_source [keep_empty state]
    let [tokens lex: get: state :source #{:comment} keep_empty
         mname_tok module_name_validation: tokens]
            map_extend!:
                map_extend!: state :module_name get: mname_tok :token_str
                :tokens tokens

; Function: setup_output
; Description: Opens a channel for indicated output or uses
; cout and sets in cmap, which is returned
; Syntax: setup_output: state
;   state - Command line flags and state settings

func :private setup_output [state]
    let output [] get: get: state :cmap :output
    ?: output
        map_extend!: state :outchannel
                open!: {
                    :channel output
                    :open :w
                    :buffer :block
                    :write_handler :char }
        map_extend!: state :outchannel cout

func :private setup_symboltable [state]
    printnl!: "Setting up sym table"
    state

func :private preload_langincs [state]
    printnl!: "Process RTL headers"
    state

func :private process_includes [state]
    printnl!: "Process includes"
    state

func :private ast_print2 [state] ; Temporary name
    printnl!: "Print AST"
    state

func :private consume_include [state]
    printnl!: "Consume include"
    state

func :private consume_includes [state]
    printnl!: "Consume includes"
    state

func :private reverse_tokens [state]
    printnl!: "Reversing tokens"
    state

func :private parse_tokens   [state]
    printnl!: "Create AST"
    state

func :private ast_print   [state]
    printnl!: "Print AST"
    state

func :private parse_tree   [state]
    printnl!: "Creating PAST"
    state

func :private produce_ir   [state]
    printnl!: "Creating 3AC"
    state

func :private ir_print   [state]
    printnl!: "Print 3AC"
    state

func :private emit_llvm   [state]
    printnl!: "Emit LLVM"
    state

; Function: func_genhdr_writer
; Description: Writes out function signature in genheader processing
; Syntax: func_genhdr_writer: ochan stok arglist acnt
;   ochan
;   stok
;   arglist
;   acnt

func :private func_genhdr_writer [ochan stok arglist acnt]
    write!: ochan "func "
    write!: ochan get: stok :token_str
    write!: ochan " ["
    ?: >: acnt zero
        fold:
            ^[acc indx]
                @(
                    ?: >: indx 0
                        write!: ochan " "
                        nil
                    write!: ochan get: arglist indx
                    acc
                )
            nil series: 0 acnt 1
        nil
    write!: ochan "]"
    write!: ochan nlchr

; Function: process_func
; Description: HOF to gather, validate and process functions in token list
; Syntax: process_func: ochan toks
func :private process_func [ochan toks cindx mxcnt func_fn]
    ; If ttype after var is :private... skip
    let nindx [] inc: cindx
    ?: is_token_type?: toks nindx :private
        inc: cindx
        ; Otherwise process it
        ?: is_token_type_in_set?: toks nindx symbol_types
            let [stok       get: toks nindx
                 arglist    get_validate_funcargs: toks nindx
                 acnt       count: arglist
                 findx      +: nindx +: acnt two]
                @(
                    (func_fn ochan stok arglist acnt)
                    inc: findx
                )
            ; Fail syntax
            fail_on_token: toks nindx " expected symbol after 'func', found "

; Function: var_genhdr_writer
; Description: Writes out variable signature in genheader processing
; Syntax: func_genhdr_writer: ochan stok arglist acnt
;   ochan
;   stok
;   arglist
;   acnt

func :private var_genhdr_writer [ochan ntok]
    write!: ochan "var "
    write!: ochan get: ntok :token_str
    write!: ochan " any"
    write!: ochan nlchr

func :private process_var [ochan toks cindx mxcnt var_fn]
    ; If ttype after var is :private... skip
    let nindx [] inc: cindx
    ?: is_token_type?: toks nindx :private
        inc: cindx
        ; If next is symbol ... success
        ?: is_token_type_in_set?: toks nindx symbol_types
            let [ntok get: toks nindx]
                @(
                    (var_fn ochan ntok)
                    inc: nindx
                )
            ; Fail syntax
            fail_on_token: toks nindx " expected symbol after 'var', found "

func :private header_token_consumer [tks ochan acc ndx]
    let [cnt count: tks]
         ?: >=: acc cnt
            reduced: acc
            let [tok get: tks acc]
                match get: tok :token_type
                | :variable     process_var: ochan tok tks acc cnt var_genhdr_writer
                | :function     process_func: ochan tks acc cnt func_genhdr_writer
                | :default inc: acc

; Function: genheader
; Description: Generates module, public vars and public funcs
; to designated output
; Rules:
;   Comment block
;   'module name'       : name is already part of state
;   'var name Any'      : name is token right after var if not :private
;   'func name [args]'  : name is token right after func if not :private
; Syntax: genheader: state
;   state - Command line flags and state settings

func :private genheader [state]
    printnl!: "Generate header"
    let ochan [] get: state :outchannel
    let tks [] get: state :tokens
    write_comment_block_and_module: ochan get: state :module_name
    ; Now walk through and spit vars
    fold: (header_token_consumer tks ochan) 0 infinite
    state

; Function: close_output
; Description: Closes, if not stdout, the output channel
; Syntax: close_output: state
;   state - Command line flags and state settings

func :private close_output [state]
    let output [] get: state :outchannel
    ?: =: output cout
        state
        close!: output
    state

; Function: skip_step
; Description: Passthrough step returns state and
; is used when the debugging (-pt, -pa, -pi) are not specified
func :private skip_step [state]
    state

; Place holder for dev
func :private faux_step [s state]
    print!: "Place holder step for " printnl!: s
    state

; Function: build_handler
; Description: Constructs a compilation pipeline based on the
; command line information
; Syntax: build_handler: cmap
;   cmap - Command line flags and settings
; pipeline examples
; If -c command
;   lex_source          - inserts tokens into state
;   [token_print]       - optionally print tokens
;   setup_output        - opens an output channel
;   setup_symboltable   - sets a symbol table up
;   [preload_langincs]  - Preprocess foidlrt and langcore if !-r
;   process_includes    - seperate include(s) from main tokens
;   consume_includes    - consume includes, calls consume_include for each
;   reverse_tokens      - support bottom up parsing
;   parse_tokens        - parse the tokens to abstract syntax tree (AST)
;   [ast_print]         - optionally prints AST
;   parse_tree          - walks AST, generate parse abstract syntax tree (PAST)
;   produce_ir          - walks PAST, creates three address code list (3AC)
;   [ir_print]          - optionally print 3AC
;   emit_llvm           - Emits LLVM-IR from 3AC
;   close_output        - Closes output channel
;
; If -g command
;   lex_source          - inserts tokens into state
;   [token_print]       - optionally print tokens
;   setup_output        - opens an output channel
;   genheader           - Emits foidl defs
;   close_output        - Closes output channel
;
; If -i command
;   lex_source          - inserts tokens into state
;   consume_include     - Generate symbol table references


func build_handler_and_run [cmap]

    let state []
        {
            :cmap           cmap
            :source         get: cmap :source
        }

    match pipeline get: cmap :command
    | :compile  [
                (lex_source false)
                ?: get: cmap :printtoks
                    token_print
                    skip_step
                setup_output
                (faux_step "setup_symboltable")
                ?: get: cmap :compiling_runtime
                    skip_step
                    (faux_step "preload_langincs")
                (faux_step "process_includes")
                (faux_step "consume_includes")
                (faux_step "reverse_tokens")
                (faux_step "parse_tokens")
                ?: get: cmap :printast
                    (faux_step "ast_print")
                    skip_step
                (faux_step "parse_tree")
                (faux_step "produce_ir")
                ?: get: cmap :printir
                    (faux_step "ir_print")
                    skip_step
                (faux_step "emit_llvm")
                close_output
                ]
    | :genhdr   [
                (lex_source false)
                ?: get: cmap :printtoks
                    token_print
                    skip_step
                setup_output
                genheader
                close_output
                ]
    | :include  [
                (faux_step "lex_source true") ; (lex_source true)
                (faux_step "consume_include")
                ]
    | :default  @(
                    write!: cerr "Invalid switch found in build_handler "
                    write!: cerr %0
                    write!: cerr nlchr
                    fail:
                )
    fold: ^[acc el] (el acc) state pipeline

