;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; parse_utils
; Parse utilities
;
; Copyright (c) Frank V. Castellucci
; All Rights Reserved
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

module parse_utils

include langcorem
include ast_type
include token_utils
include symbol_table


func add_nil_expr [node]
    ?: =: count: get: node EXPRS zero
        extend!: get: node EXPRS st_lookup: "nil"
        failWith: "Attempt to add nil to populated list"
    node

; Function: process_for_private
; Description: Used by vars and funcs which have
; optional ':private' modifier on declaration
; Syntax: process_for_private: node ast_tree

func process_for_private [node ast_tree]
    let pnode [] first: ast_tree
    let vpsym [] get: pnode TYPE
    ?: =: vpsym :private
        @(
            map_extend!: node IS_PRIVATE true
            drop!: ast_tree one
            let [vvsym get: first: ast_tree NAME]
                map_extend!: node NAME get: vvsym NAME
        )
        map_extend!: node NAME get: pnode NAME
    drop!: ast_tree one

; Function:
; Description:
; Syntax:

func :private index_to_reduction [ast_tree pred_fn res ndx]
    ?: (pred_fn get: ast_tree ndx)
        reduced: ndx
        res

; Function:
; Description:
; Syntax:

func index_to_type [ast_tree pred_fn]
    fold:
        (index_to_reduction ast_tree pred_fn)
        zero series: zero count: ast_tree one


; Function: until_pred
; Description: Iterates until predicate reduces
; Syntax:

func until_pred [foreach_fn init]
    fold: foreach_fn init infinite

; Collection type support

var :private coll_lookup {
    :lbracket   :rbracket
    :lbrace     :rbrace
    :lset       :rbrace
    :lvector    :rvector
}

var :private coll_type {
    :lbracket   :list
    :lbrace     :map
    :lset       :set
    :lvector    :vector
}

; Function: collindex_pred
; Description: Predicate used during collection
; building that tests if passed is token type of
; endtype
; Syntax:

func :private collindex_pred [endtype tok]
    =: get: tok :token_type endtype

; Function: for_each_collelem
; Description: Process each ast_tree expression until
; predicate returns true
; Syntax:

func :private for_each_collelem [pred_fn ast_tree node indx]
    ?: (pred_fn first: ast_tree)
        reduced: node
        @(
            list_extend!: get: node EXPRS first: ast_tree
            pop!: ast_tree
            node
        )


; Function: parse_collection
; Description: Processing a collection by locating it's
; companion closing token and inferencing type and
; collecting elements. Maps have a modulo 2 test
; Syntax:

func parse_collection [stok ast_tree srcname]
    let stype [] get: stok :token_type
    let tail [] get: coll_lookup stype
    let ctype [] get: coll_type stype
    let pred_fn [] (collindex_pred tail)
    let tindx [] index_to_type: ast_tree pred_fn
    let node []
        ?: =: tindx zero
            map_extend!:
                type_with_exprs: :empty_collection srcname stok
                COLLTYPE ctype
            until_pred:
                (for_each_collelem pred_fn ast_tree)
                map_extend!:
                    type_with_exprs: :collection srcname stok
                    COLLTYPE ctype

    ?: and: =: get: node TYPE :collection =: get: node COLLTYPE :map
        ?: =: mod: count: get: node EXPRS two zero
            nil
            @(
                write!: cerr "Map requires even pairs"
                fail:
            )
        nil

    pop!: ast_tree  ;   Get rid of tail
    node


func :private invalid_arglist [fnode node]
    let tok [] get: fnode :token
    fail_token_header: tok
    write!: cerr " function "
    write!: cerr get: fnode NAME
    write!: cerr " expects arglist [...]"
    write!: cerr nlchr
    fail:

func :private invalid_arg [fnode node]
    let tok [] get: fnode :token
    fail_token_header: tok
    write!: cerr " function "
    write!: cerr get: fnode NAME
    write!: cerr " expects symbols in arglist. Found "
    write!: cerr get: node TYPE
    write!: cerr nlchr
    fail:

; Function:
; Description:
; Syntax:

func :private verify_symbol_list [fnode node]
    ?: =: get: node TYPE :empty_collection
        node
        let [exprs get: node EXPRS]
            fold: ^[res el]
                ?: =: get: el TYPE :symbol
                    res
                    invalid_arg: fnode el
                node exprs

; Function: verify_func_args
; Description: Checks that argsig exists, and if not empty
; verify all are symbols then set in node after removing
; from ast_tree.

func verify_func_args [node ast_tree]
    let ifla [] is_funclambda_args?: first: ast_tree
    ?: ifla
        map_extend!:
            node
            ARGLIST
            verify_symbol_list: node first: ast_tree
        invalid_arglist: node first: ast_tree
    pop!: ast_tree

; Function:
; Description:
; Syntax:

func :private for_each_expr [node ast_tree res ndx]
    let fval [] first: ast_tree
    ?: or: nil?: fval is_decl?: fval
        ?: =: count: get: node EXPRS zero
            reduced: add_nil_expr: node
            reduced: node
        @(
            list_extend!: get: node EXPRS fval
            pop!: ast_tree
            node
        )

; Function:
; Description:
; Syntax:

func get_func_exprs [node ast_tree]
    until_pred:
        (for_each_expr node ast_tree)
        node
