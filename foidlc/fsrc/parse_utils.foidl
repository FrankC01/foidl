;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; parse_utils
; Parse utilities
;
; Copyright (c) Frank V. Castellucci
; All Rights Reserved
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

module parse_utils

include langcorem
include ast_type
include token_utils
include symbol_table


func add_nil_expr [node]
    ?: =: count: get: node EXPRS zero
        extend!: get: node EXPRS st_lookup: "nil"
        failWith: "Attempt to add nil to populated list"
    node

; Function: process_for_private
; Description: Used by vars and funcs which have
; optional ':private' modifier on declaration
; Syntax: process_for_private: node ast_tree

func process_for_private [node ast_tree]
    let pnode [] first: ast_tree
    let vpsym [] get: pnode TYPE
    ?: =: vpsym :private
        @(
            map_extend!: node IS_PRIVATE true
            pop!: ast_tree
            let [vvsym get: first: ast_tree NAME]
                map_extend!: node NAME vvsym
        )
        map_extend!: node NAME get: pnode NAME
    pop!: ast_tree

; Function:
; Description:
; Syntax:

func :private index_to_reduction [ast_tree pred_fn res ndx]
    ?: (pred_fn get: ast_tree ndx)
        reduced: ndx
        res

; Function:
; Description:
; Syntax:

func index_to_type [ast_tree pred_fn]
    fold:
        (index_to_reduction ast_tree pred_fn)
        zero series: zero count: ast_tree one


; Function: until_pred
; Description: Iterates until predicate reduces
; Syntax:

func until_pred [foreach_fn init]
    fold: foreach_fn init infinite

; Collection type support

var :private coll_lookup {
    :lbracket   :rbracket
    :lbrace     :rbrace
    :lset       :rbrace
    :langle     :rangle
}

var :private coll_type {
    :lbracket   :list
    :lbrace     :map
    :lset       :set
    :langle     :vector
}

; Function: collindex_pred
; Description: Predicate used during collection
; building that tests if passed is token type of
; endtype
; Syntax:

func :private collindex_pred [endtype tok]
    =: get: tok :token_type endtype

; Function: for_each_collelem
; Description: Process each ast_tree expression until
; predicate returns true
; Syntax:

func :private for_each_collelem [pred_fn ast_tree node indx]
    ?: (pred_fn first: ast_tree)
        reduced: node
        @(
            list_extend!: get: node EXPRS first: ast_tree
            pop!: ast_tree
            node
        )


; Function: parse_collection
; Description: Processing a collection by locating it's
; companion closing token and inferencing type and
; collecting elements. Maps have a modulo 2 test
; Syntax:

func parse_collection [stok ast_tree srcname]
    printnl!: stok
    let stype [] get: stok :token_type
    let tail [] get: coll_lookup stype
    let ctype [] get: coll_type stype
    let pred_fn [] (collindex_pred tail)
    let tindx [] index_to_type: ast_tree pred_fn
    let node []
        ?: =: tindx zero
            map_extend!:
                type_with_exprs: :empty_collection srcname stok
                COLLTYPE ctype
            until_pred:
                (for_each_collelem pred_fn ast_tree)
                map_extend!:
                    type_with_exprs: :collection srcname stok
                    COLLTYPE ctype

    ?: and: =: get: node TYPE :collection =: get: node COLLTYPE :map
        ?: =: mod: count: get: node EXPRS two zero
            nil
            @(
                fail_token_header: stok
                write!: cerr "Map requires even pairs"
                write!: cerr nlchr
                fail:
            )
        nil

    pop!: ast_tree  ;   Get rid of tail
    node


func :private invalid_arglist [fnode node]
    let tok [] get: fnode :token
    fail_token_header: tok
    write!: cerr " function "
    write!: cerr get: fnode NAME
    write!: cerr " expects arglist [...]"
    write!: cerr nlchr
    fail:

func :private invalid_arg [fnode node]
    let tok [] get: fnode :token
    fail_token_header: tok
    write!: cerr " function "
    write!: cerr get: fnode NAME
    write!: cerr " expects symbols in arglist. Found "
    write!: cerr get: node TYPE
    write!: cerr nlchr
    fail:

; Function:
; Description:
; Syntax:

func :private verify_symbol_list [fnode node]
    ?: =: get: node TYPE :empty_collection
        node
        let [exprs get: node EXPRS]
            fold: ^[res el]
                ?: =: get: el TYPE :symbol
                    res
                    invalid_arg: fnode el
                node exprs

; Function: verify_func_args
; Description: Checks that argsig exists, and if not empty
; verify all are symbols then set in node after removing
; from ast_tree.

func verify_func_args [node ast_tree]
    let ifla [] is_funclambda_args?: first: ast_tree
    ?: ifla
        map_extend!:
            node
            ARGLIST
            verify_symbol_list: node first: ast_tree
        invalid_arglist: node first: ast_tree
    pop!: ast_tree


; Function: is_next_nil_or_decl?
; Description: Determines if first item in list is nil
; or a module, include, var or func declaration
; Syntax:

func is_next_nil_or_decl? [list_coll]
    let nval [] first: list_coll
    or: nil?: nval is_decl?: nval

; Function: for_each_expr
; Description: Consumes expression until end or
; declaration found. If end or declaration, puts
; a 'nil' expression in nodes expressions

func :private for_each_expr [node ast_tree res ndx]

    ?: is_next_nil_or_decl?: ast_tree
        ?: =: count: get: node EXPRS zero
            reduced: add_nil_expr: node
            reduced: node
        @(
            list_extend!: get: node EXPRS first: ast_tree
            pop!: ast_tree
            node
        )

; Function: get_func_exprs
; Description: Get all expressions until next declaration or
; end of list

func get_func_exprs [node ast_tree]
    until_pred:
        (for_each_expr node ast_tree)
        node

; Function: get_var_expr
; Description: Get a single expression or nil expression
; if ast is end (nil) or another declaration put the
; 'nil' expression in the nodes expression list

func get_var_expr [node ast_tree]
    ?: is_next_nil_or_decl?: ast_tree
        add_nil_expr: node
        @(
            list_extend!: get: node EXPRS first: ast_tree
            pop!: ast_tree
            node
        )

; Function: get_single_expr
; Description: Gets a single expression or fails if none found

func get_single_expr [node ast_tree]
    ?: is_next_nil_or_decl?: ast_tree
        @(
            fail_token_header: get: node :token
            write!: cerr " expected a single expression to follow "
            write!: cerr nlchr
            fail:
        )
        @(
            list_extend!: get: node EXPRS first: ast_tree
            pop!: ast_tree
            node
        )

func :private validate_expressions [mnode estr acc node]
    ?: and: node not: is_decl?: node
        list_extend!: acc node
        @(
            fail_token_header: get: mnode :token
            write!: cerr estr
            write!: cerr nlchr
            fail:
        )


; Function: parse_if
; Description: Parse 3 expressions ensuring non are
; not nil or a declaration

func parse_if [node ast_tree]
    let if_expr []
                [
                    first: ast_tree
                    second: ast_tree
                    get: ast_tree two
                ]
    fold:
        (validate_expressions
            node
            " incomplete if statement. Requires three (3) expressions.")
        get: node EXPRS if_expr
    drop!: ast_tree three

