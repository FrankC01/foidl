;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; emit_utils
; LLVM Generation
;
; Copyright (c) Frank V. Castellucci
; All Rights Reserved
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

module emit_utils

include langcorem
include ir_types
include ast_type
include errors

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Literal support
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Function: emit_literals
; Description: Creates literal declaration instructions

func emit_literal_declarations [acc el]
    ?: empty?: value: el
        acc
        fold:
            ^[instr lit]
                list_extend!:
                    instr
                    literal_type: value: lit
            acc value: el

; Function: literal_max_len
; Description: Gets the maximum string/keyword len for
; those types

func literal_max_len [bblock max_cnt ndx]

    let element      [] get: bblock ndx
    let element_type [] get: element :ltype
    let element_cnt  [] count: get: element :lval

    ?: get: #{:keyword :string} element_type
        ?: >: element_cnt max_cnt
            ?: =: element_type :keyword
                element_cnt
                -: element_cnt two
            max_cnt
        max_cnt

; Function: literal_buffer_setup
; Description: Prepares buffer and basecast information for handling
; string and keyword runtime registrations

func literal_buffer_setup [lit_fn lit_bb lit_maxlen]
    ; Local (stack) array to fit max string and/or keyword
    let sbuff []
        array_type: int_8 inc: lit_maxlen
    ; Prep instruction push
    let inst [] get: lit_bb :instructions
    ; Allocate the buffer
    let abuf [] alloca: lit_fn sbuff
    list_extend!: inst abuf
    ; Reference pointer to array register
    let voidpref []
        reference_register_type:
            sbuff
            get: abuf :register

    let bc [] bitcast: lit_fn voidpref void_ptr
    list_extend!: inst bc
    bc

; Function: literal_chartype_registration
; Description: Registers a type of char string (string, keyword)

func :private literal_chartype_registration [
    basecast lit_fn lit_bb regc sval sname scnt]
    ; Create an array signature based on size of input
    let va  [] array_type: int_8 scnt
    let brt [] reference_register_type: int_8 get: basecast :register
    ; Bitcast the base to the array pointer and preserve
    ; the register
    let bc []
        bitcast:
            lit_fn
            brt
            ptr_type: va
    list_extend!: lit_bb bc
    let bic [] get: bc :register

    ; Create the store of the target to the stack
    list_extend!: lit_bb
        store:
            reference_constant_type: va const_string_type: sval
            reference_register_type: va bic

    ; Call the registration function using the base bitcast register
    let reg_call []
        call:
            lit_fn
            regc
            [brt]
    list_extend!: lit_bb reg_call

    ; Store the result
    list_extend!:
        lit_bb
        store:
            reference_register_type: any get: reg_call :register
            reference_constant_type: any_ptr_ptr global_reference: sname

; Function: literal_string
; Description: Prepare a string registration at initialization

func :private literal_string    [basecast lit_fn lit_bb lit_string]
    let lstr [] rest: dropLast: get: lit_string :lval
    literal_chartype_registration:
        basecast
        lit_fn
        lit_bb
        global_reference: "foidl_reg_string"
        lstr
        get: lit_string :name
        count: lstr

; Function: literal_keyword
; Description: Prepare a keyword registration at initialization

func :private literal_keyword   [basecast lit_fn lit_bb lit_keyword]
    let lstr [] get: lit_keyword :lval
    literal_chartype_registration:
        basecast
        lit_fn
        lit_bb
        global_reference: "foidl_reg_keyword"
        lstr
        get: lit_keyword :name
        inc: count: lstr

; Function: literal_integer
; Description: Prepare an integer registration at initialization

func :private literal_integer   [lit_fn lit_bb lit_integer]

    let int_reg [] global_reference: "foidl_reg_integer"
    ; Call register_int
    let reg_call []
        call:
            lit_fn
            int_reg
            [reference_constant_type: int_64 const_type: get: lit_integer :lval]
    list_extend!: lit_bb reg_call
    ; Store the result to the const literal
    list_extend!:
        lit_bb
        store:
            reference_register_type:
                any
                get: reg_call :register
            reference_constant_type:
                any_ptr_ptr
                global_reference: get: lit_integer :name


; Function: literal_registration
; Description: For each literal, add to the "modulename_linits" function

func literal_registration [basecast lit_fn lit_bb literals ndx]
    let lit [] get: literals ndx
    match get: lit :ltype
    | :string   literal_string: basecast lit_fn lit_bb lit
    | :keyword  literal_keyword: basecast lit_fn lit_bb lit
    | :integer  literal_integer: lit_fn lit_bb lit
    literals

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generic function support
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

var :private globals_map map_inst!:

func new_function [asttype]
    ; Arguments are reduced to names only
    let args []
        fold:
            ^[acc el]
                list_extend!: acc get: el NAME
            list_inst!: get: get: asttype ARGLIST EXPRS
    let gf []
        global_function_type:
            get: asttype NAME
            get: asttype IS_PRIVATE
            args
            "%`dAny`d*"
            return_void
    map_extend!:
        globals_map
        get: asttype NAME
        gf
    gf


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Not implemented expression support
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func :private default_expression_handler [scope_fn frame scope_bb etype]
    warning:
        format!:
            "No emit implementation for {}" [get: etype TYPE]
    scope_bb

func :private nohit_expression_handler [acc k]
    default_expression_handler

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Utilities
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Function: lastcall_to_regref
; Description: Create a register reference from instruction

func :private lastcall_to_regref [ instruction ]
    reference_register_type:
        any
        get: instruction :register

; Function: load_funcreference
; Description: Instantiate a function instance reference from a function
; signature, performing bitcasts and registrations as needed. Returns
; a register reference

func :private load_funcreference [scope_fn scope_bb gfref]
    let argcnt [] count: get: gfref :arguments
    ; Call register_int for number of argumnets to funcref
    let reg_call []
        call:
            scope_fn
            global_reference: "foidl_reg_integer"
            [reference_constant_type: int_64 const_type: argcnt]
    list_extend!: scope_bb reg_call
    ; Bitcast to a void*
    let bc []
        bitcast:
            scope_fn
            funcref_type:
                get: gfref :name
                any_ptr
                argcnt
            void_ptr
    list_extend!: scope_bb bc
    ; Call the function instance creator
    let fref_call []
        call:
            scope_fn
            global_reference: "foidl_tofuncref"
            [
                reference_constant_type: void_ptr get: bc :register
                reference_constant_type: any_ptr get: reg_call :register
            ]
    list_extend!: scope_bb fref_call
    ; Return a register reference type for last call
    lastcall_to_regref: fref_call

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Heavy lifting emit support
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Function: emit_call
; Description: Emit each expression and
; capture references to eval result as arguments to call

func :private emit_call [scope_fn frame scope_bb etype]
    let args [] list_inst!:
    expression_emitter: scope_fn args scope_bb get: etype EXPRS
    let call_instr []
        call:
            scope_fn
            global_reference: get: etype NAME
            args

    list_extend!: frame lastcall_to_regref: call_instr
    list_extend!: scope_bb call_instr


; Function: emit_lambda_call
; Description: Instructions to load a lambda reference
; to register. Basic block instructions created in
; load_funcreference:

func :private emit_lambda_call [scope_fn frame scope_bb etype]
    list_extend!:
        frame
        load_funcreference:
            scope_fn
            scope_bb
            get: globals_map get: etype NAME
    scope_bb

; Function: emit_collection
; Description: Emits a stream of collection expressions

func :private single_element_coll [scope_fn scope_bb instname setname etype]
    ;   Instance creator
    let inst_call []
        call:
            scope_fn
            global_reference: instname
            []
    list_extend!: scope_bb inst_call
    lastcall_to_regref: inst_call


func :private emit_collection [scope_fn frame scope_bb etype]
    match res get: etype COLLTYPE
    | :list     single_element_coll: scope_fn scope_bb "list_inst!" "list_extend!" etype
    | :vector   printnl!: "Emit Vector"
    | :map      printnl!: "Emit Map"
    | :set      printnl!: "Emit Set"
    | :default  exception: etype
    list_extend!: frame res
    scope_bb

; Function: emit_global_ref
; Description: Instruction to loads reference of type global
; into register
func :private emit_global_ref [scope_fn frame scope_bb etype]
    let load_inst []
        load:
            scope_fn
            any_ptr
            reference_constant_type:
                any_ptr_ptr
                global_reference: get: etype NAME

    list_extend!: frame lastcall_to_regref: load_inst
    list_extend!: scope_bb load_inst

; Function: emit_local_argref
; Description: Collects constant local reference for
; use, this is not an instruction emit

func :private emit_local_argref [scope_fn frame scope_bb etype]
    list_extend!:
        frame
        reference_constant_type:
            any_ptr
            const_reference: get: etype NAME
    scope_bb

var :private emit_handlers
    {
        :call           emit_call
        :lambda_call    emit_lambda_call
        :collection     emit_collection
        :lambda_argref  emit_local_argref
        :funcargref     emit_local_argref
        :literalref     emit_global_ref
        :varref         emit_global_ref
    }

func dispatch_expression [scope_fn frame scope_bb expr_el]
    let e_fn []
        getd:
            emit_handlers
            get: expr_el TYPE
            nohit_expression_handler
    (e_fn scope_fn frame scope_bb expr_el)

func expression_emitter [scope_fn frame scope_bb exprs]
    fold: (dispatch_expression scope_fn frame) scope_bb exprs
    scope_bb


