;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; emit_utils
; LLVM Generation
;
; Copyright (c) Frank V. Castellucci
; All Rights Reserved
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

module emit_utils

include langcorem
include ir_types

; Function: emit_literals
; Description: Creates literal declaration instructions

func emit_literal_declarations [acc el]
    ?: empty?: value: el
        acc
        fold:
            ^[instr lit]
                list_extend!:
                    instr
                    literal_type: value: lit
            acc value: el

; Function: literal_max_len
; Description: Gets the maximum string/keyword len for
; those types

func literal_max_len [bblock max_cnt ndx]

    let element      [] get: bblock ndx
    let element_type [] get: element :ltype
    let element_cnt  [] count: get: element :lval

    ?: get: #{:keyword :string} element_type
        ?: >: element_cnt max_cnt
            ?: =: element_type :keyword
                element_cnt
                -: element_cnt two
            max_cnt
        max_cnt

; Function: literal_buffer_setup
; Description: Prepares key information for handling
; string and keyword runtime registrations

func literal_buffer_setup [lit_fn lit_bb lit_maxlen litinfo_map]
    ; Local (stack) array to fit max string and/or keyword
    let sbuff []
        array_type: int_8 inc: lit_maxlen
    ; Reference pointer to array register
    let voidpref []
        reference_register_type:
        sbuff
        get: alloca: lit_fn lit_bb sbuff :register

    ; Bitcast to void pointer i8*
    map_extend!:
        map_extend!:
            litinfo_map
            :basecast  bitcast: lit_fn lit_bb voidpref void_ptr
        :bufferptr_ref voidpref


;var :private

func :private literal_string    [litinfo_map lit_fn lit_bb lit_string]
    let bc [] get: litinfo_map :basecast
    let str_reg [] global_reference: "foidl_reg_string"
    ; Create the bitcast of i8* to the array of target string
    let vl [] get: lit_string :lval
    let va [] array_type: int_8 dec: count: vl
    let vap [] ptr_type: va
    let voidpref []
        reference_register_type:
        int_8
        get: bc :register
    let bic [] bitcast: lit_fn lit_bb voidpref vap
    ; Create the store of the string to the stack
    let toref []
        reference_register_type:
            va
            get: bic :register
    let strc [] const_string_type: rest: dropLast: vl
    store:
        lit_bb
        reference_constant_type:
            va
            strc
        toref
    ; Call the keyword registration
    let reg_call []
        call:
            lit_fn
            lit_bb
            str_reg
            [reference_register_type: int_8 get: bic :register]
    ; Store the result to the const literal
    store:
        lit_bb
        reference_register_type:
            any
            get: reg_call :register
        reference_constant_type:
            any_ptr_ptr
            global_reference: get: lit_string :name
    lit_string

func :private literal_keyword   [litinfo_map lit_fn lit_bb lit_keyword]
    let bc [] get: litinfo_map :basecast
    let kwd_reg [] global_reference: "foidl_reg_keyword"
    ; Create the bitcast of i8* to the array of target string
    let vl [] get: lit_keyword :lval
    let va [] array_type: int_8 inc: count: vl
    let vap [] ptr_type: va
    let voidpref []
        reference_register_type:
        int_8
        get: bc :register
    let bic [] bitcast: lit_fn lit_bb voidpref vap
    ; Create the store of the string to the stack
    let toref []
        reference_register_type:
            va
            get: bic :register
    let strc [] const_string_type: vl
    store:
        lit_bb
        reference_constant_type:
            va
            strc
        toref
    ; Call the keyword registration
    let reg_call []
        call:
            lit_fn
            lit_bb
            kwd_reg
            [reference_register_type: int_8 get: bic :register]
    ; Store the result to the const literal
    store:
        lit_bb
        reference_register_type:
            any
            get: reg_call :register
        reference_constant_type:
            any_ptr_ptr
            global_reference: get: lit_keyword :name
    lit_keyword

func :private literal_integer   [lit_fn lit_bb lit_integer]
    ;let int_reg [] global_reference: "foidl_reg_integer"
    let int_reg [] global_reference: "foidl_reg_integer"
    ; Call register_int
    let reg_call []
        call:
            lit_fn
            lit_bb
            int_reg
            [reference_constant_type: int_64 const_type: get: lit_integer :lval]
    ; Store the result to the const literal
    store:
        lit_bb
        reference_register_type:
            any
            get: reg_call :register
        reference_constant_type:
            any_ptr_ptr
            global_reference: get: lit_integer :name


func literal_registration [litinfo_map lit_fn lit_bb literals ndx]
    let lit [] get: literals ndx
    match get: lit :ltype
    | :string   literal_string: litinfo_map lit_fn lit_bb lit
    | :keyword  literal_keyword: litinfo_map lit_fn lit_bb lit
    | :integer  literal_integer: lit_fn lit_bb lit
    literals
