# ------------------------------------------------------------------------------
# Copyright 2018 Frank V. Castellucci
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ------------------------------------------------------------------------------

import ast
from abc import ABC, abstractmethod

_std_comment = """
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generated by pfoidl - Bootstrap FOIDL Compiler generator
; Copyright (c) Frank V. Castellucci
; All rights reserved
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
"""


class SimpleBundle(object):
    """SimpleBundle contains src and resulting AST"""

    def __init__(self, inc_paths, srcfile, ast):
        self._inc_paths = inc_paths
        self._src_file = srcfile
        self._ast = ast

    @property
    def inc_paths(self):
        return self._inc_paths

    @property
    def src_file(self):
        return self._src_file

    @property
    def ast(self):
        return self._ast


class Bundle(SimpleBundle):
    """Main Bundle contains essential elements for action Handlers"""

    def __init__(self, inc_paths, srcfile, ast, outhandle, outfile):
        super().__init__(inc_paths, srcfile, ast)
        self._out = outhandle
        self._out_file = outfile
        self._triple = None

    @property
    def out(self):
        return self._out

    @property
    def out_file(self):
        return self._out_file


class Handler(ABC):
    """Handler is pfoild abstract action handler class"""

    def __init__(self, bundle):
        self._bundle = bundle

    @property
    def bundle(self):
        return self._bundle

    @classmethod
    def handler_for(cls, action, bundle):
        if action == 'comp':
            return Comp(bundle)
        elif action == 'hdr':
            return Hdr(bundle)
        elif action == 'diag':
            return Diag(bundle)
        else:
            return None

    @abstractmethod
    def validate(self):
        pass

    @abstractmethod
    def emit(self):
        pass

    def write(self, s):
        print(s, file=self.bundle.out)

    def complete(self):
        if self.bundle.out_file == 'stdout':
            pass
        else:
            self.bundle.out.flush()
            self.bundle.out.close()


class Comp(Handler):
    def __init__(self, bundle):
        super().__init__(bundle)

    def validate(self):
        # Load any imports
        # Extrapolate literals
        # Generate symbol tree
        # Refactor code and identifiers
        pass

    def emit(self):
        self.write(_std_comment)
        self.complete()


class Hdr(Handler):
    """Header generation handler"""

    def __init__(self, bundle):
        super().__init__(bundle)

    def validate(self):
        self.write(_std_comment)

    def emit(self):
        """Hdr.emit() generates header content"""
        mod = self.bundle.ast.value[0]
        self.write("module {}".format(mod.name))
        for d in mod.value:
            if type(d) is ast.Variable:
                self.write("var {} Any".format(d.name))
            elif type(d) is ast.Function:
                self.write("func {} [{}]".format(
                    d.name,
                    ' '.join([str(s.value) for s in d.value[0].value])))
        self.complete()


class Diag(Comp):
    def __init__(self, bundle):
        super().__init__(bundle)

    def emit(self):
        self.write(_std_comment)
        self.complete()
