# ------------------------------------------------------------------------------
# Copyright 2018 Frank V. Castellucci
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ------------------------------------------------------------------------------

import os
import logging
import functools

import ast
import util
from errors import NotFoundError
from enums import ParseLevel

from abc import ABC, abstractmethod

LOGGER = logging.getLogger()

_std_comment = """
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generated by pfoidl - Bootstrap FOIDL Compiler generator
; Copyright (c) Frank V. Castellucci
; All rights reserved
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
"""


def _build_comp(*functions):
    """Construct composition"""
    return functools.reduce(
        lambda f, g: lambda x: f(g(x)), functions, lambda x: x)


def _lite_comp(input):
    LOGGER.debug("Parsing {}".format(input))
    return util.parse_file(input)


def _top_symbols(input):
    LOGGER.debug("Extracting symsbols from {}".format(input))
    return input


def _inc_to_syms():
    return _build_comp(_top_symbols, _lite_comp)


_HDR_PARSE = _inc_to_syms()


class SimpleBundle(object):
    """SimpleBundle contains src and resulting AST"""

    def __init__(self, inc_paths, srcfile, ast):
        self._inc_paths = inc_paths
        self._src_file = srcfile
        self._ast = ast

    @property
    def inc_paths(self):
        return self._inc_paths

    @property
    def src_file(self):
        return self._src_file

    @property
    def ast(self):
        return self._ast


class Bundle(SimpleBundle):
    """Main Bundle contains essential elements for action Handlers"""

    def __init__(self, inc_paths, srcfile, ast, outhandle, outfile):
        super().__init__(inc_paths, srcfile, ast)
        self._out = outhandle
        self._out_file = outfile
        self._triple = None

    @property
    def out(self):
        return self._out

    @property
    def out_file(self):
        return self._out_file


class Handler(ABC):
    """Handler is pfoild abstract action handler class"""

    def __init__(self, bundle):
        self._bundle = bundle

    @property
    def bundle(self):
        return self._bundle

    @classmethod
    def handler_for(cls, action, bundle):
        if action == 'comp':
            return Comp(bundle)
        elif action == 'compr':
            return RTComp(bundle)
        elif action == 'hdr':
            return Hdr(bundle)
        elif action == 'diag':
            return Diag(bundle)
        else:
            return None

    @abstractmethod
    def validate(self):
        pass

    @abstractmethod
    def emit(self):
        pass

    def write(self, s):
        print(s, file=self.bundle.out)

    def complete(self):
        if self.bundle.out_file == 'stdout':
            pass
        else:
            self.bundle.out.flush()
            self.bundle.out.close()


class BaseComp(Handler):
    def __init__(self, bundle):
        super().__init__(bundle)
        self._imports = []
        LOGGER.info("Initiating compile")

    def compute_include(self):
        include = self.bundle.ast.include
        # For each file include

        def resolve_hdr_file(fname):
            for p in self.bundle.inc_paths:
                hfile = util.file_exists(p, fname, 'defs')
                if hfile:
                    return hfile
            return None

        inc_files = []
        for i in include.value:
            ffile = resolve_hdr_file(i.value)
            if ffile:
                inc_files.append(ffile)
            else:
                raise NotFoundError(
                    "Unable to resolve include file {}".format(i.value))
        return inc_files

    def validate(self):
        # Load any includes
        r = [_HDR_PARSE(x) for x in self.compute_include()]
        LOGGER.debug(r)
        # Extrapolate literals
        # Generate symbol tree
        # Refactor code and identifiers
        pass

    def emit(self):
        self.write(_std_comment)
        self.complete()


class Comp(BaseComp):
    def __init__(self, bundle):
        super().__init__(bundle)
        if "FOIDLC2_PATH" in os.environ:
            self.bundle.inc_paths.insert(
                0,
                os.environ.get("FOIDLC2_PATH"))
        include = self.bundle.ast.include
        include.value.insert(
            0,
            ast.Symbol('langcore2', include.token, include.source))
        include.value.insert(
            0,
            ast.Symbol('foidlrt2', include.token, include.source))

    def validate(self):
        # Load system imports first
        # Load any imports
        # Extrapolate literals
        # Generate symbol tree
        # Refactor code and identifiers
        super().validate()
        pass


class RTComp(BaseComp):
    def __init__(self, bundle):
        super().__init__(bundle)
        # Does not set runtimes


class Hdr(Handler):
    """Header generation handler"""

    def __init__(self, bundle):
        super().__init__(bundle)
        LOGGER.info("Initiating header gen")

    def validate(self):
        self.write(_std_comment)

    def emit(self):
        """Hdr.emit() generates header content"""
        mod = self.bundle.ast
        self.write("module {}".format(mod.name))
        for d in mod.value:
            if type(d) is ast.Variable:
                self.write("var {} Any".format(d.name))
            elif type(d) is ast.Function:
                self.write("func {} [{}]".format(
                    d.name,
                    ' '.join([str(s.value) for s in d.value[0].value])))
        self.complete()


class Diag(Comp):
    def __init__(self, bundle):
        super().__init__(bundle)

    def emit(self):
        self.write(_std_comment)
        self.complete()
